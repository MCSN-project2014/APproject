using System.Collections;
using System.Collections.Generic;

COMPILER Fun

	/*const int // types
	  undef = 0, integer = 1, boolean = 2, fun = 3;

	const int // object kinds
	  var = 0, proc = 1, func = 2, form = 3, act=4;
	*/
	
	public SymbolTable   tab;
	public CodeGenerator gen;
/*--------------------------------------------------------------------------*/
CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*------------------------------------------------------------------------*/
AddOp<out Op op>
=                        (. op = Op.ADD; .)
  ( '+'
  | '-'                  (. op = Op.SUB; .)
  ).

/*------------------------------------------------------------------------*/
Expr<out Types type>       (. Types type1; Op op; .)
= SimExpr<out type>
  [ RelOp<out op>
    SimExpr<out type1>   (. if (type != type1) SemErr("incompatible types");
                            type = Types.boolean; .)
  ].

/*------------------------------------------------------------------------*/
Factor<out Types type>     (. int n; Obj obj; string name; .)
=                        (. type = Types.fun; .)
  ( Ident<out name>      (. obj = tab.Find(name); type = obj.type;
                            if (obj.kind != Kinds.var && obj.kind != Kinds.form) SemErr("variable expected"); 
						 .)
  | number               (. n = Convert.ToInt32(t.val);
                            type = Types.integer; .)
  | '-'
    Factor<out type>     (. if (type != Types.integer) {
                              SemErr("integer type expected");
							  type = Types.integer;
                            }
							 .)
  | "true"               (.  type = Types.boolean; .)
  | "false"              (.  type = Types.boolean; .)
  ).
/*------------------------------------------------------------------------*/
Ident<out string name>
= ident                  (. name = t.val; .).
/*------------------------------------------------------------------------*/
MulOp<out Op op>
=                        (. op = Op.MUL; .)
  ( '*'
  | '/'                  (. op = Op.DIV; .)
  ).
/*------------------------------------------------------------------------*/
ProcDecl                  (. Types type; string name; Obj obj; int adr; .)
= "fun" (
  Ident<out name>         (. obj = tab.NewObj(name, Kinds.proc, Types.undef); obj.adr = gen.pc;
                             tab.OpenScope(); .)
  '(' {Ident<out name>

	   Type<out type>     (. tab.NewObj(name, Kinds.form, type); .)

	   {','Ident<out name>
	   Type<out type>     (. tab.NewObj(name, Kinds.form, type); .)
	   }                  (. tab.setformsof(obj);
	       				   .)
	   }  ')'
  '{'                     (. adr = gen.pc - 2; .)
  { VarDecl | Stat }
  '}' RType<out type>     (. obj.type = type; .)
							(. tab.CloseScope(); .)
  | "main"                (. obj = tab.NewObj("Main", Kinds.proc, Types.undef); obj.adr = gen.pc;

                            gen.progStart = gen.pc;
                            tab.OpenScope(); .)
  '(' ')'
  '{'                     (. adr = gen.pc - 2; .)
  { VarDecl | Stat }
  '}'                     (.  tab.CloseScope(); .)
).
/*------------------------------------------------------------------------*/
RelOp<out Op op>
=                        (. op = Op.EQU; .)
  ( "=="
  | '<'                  (. op = Op.LSS; .)
  | '>'                  (. op = Op.GTR; .)
  ).
/*------------------------------------------------------------------------*/
SimExpr<out Types type>    (. Types type1; Op op; .)
= Term<out type>
  { AddOp<out op>
    Term<out type1>      (. if (type != Types.integer || type1 != Types.integer)
                              SemErr("integer type expected"); .)
	}.
/*------------------------------------------------------------------------*/
Stat                     (. Types type; string name; Obj obj; Queue<Types> actualTypes = new Queue<Types>();
                            int adr; .)
= Ident<out name>        (. obj = tab.Find(name); .)
  ( '='                  (. if ( !(obj.kind == Kinds.var || obj.kind == Kinds.form) )
								SemErr("cannot assign to procedure"); .)
		Expr<out type> ';'
						 (. if (type != obj.type) SemErr("incompatible types"); .)

	| '('{ Expr<out type>      (. actualTypes.Enqueue(type); .) 
           { ',' Expr<out type>  (. actualTypes.Enqueue(type); .)
		  }  }')' ';'
						 (. if (obj.kind != Kinds.proc) SemErr("object is not a procedure");
							tab.checkActualFormalTypes(obj,actualTypes);
						 .)
	)

| "if"
	'(' Expr<out type> ')' (. if (type != Types.boolean) SemErr("boolean type expected");
							  adr = gen.pc - 2; .)
	Stat
	[ "else"  Stat ]          

| "while"                  
	'(' Expr<out type> ')' (. if (type != Types.boolean) SemErr("boolean type expected"); .)
	Stat                   

| '{' { Stat | VarDecl } '}' .
/*------------------------------------------------------------------------*/
Fun
=                        (. tab.OpenScope(); .)
  ProcDecl { ProcDecl }
                         (. tab.CloseScope();
                            if (gen.progStart == -1) 
							SemErr("main function never defined");
                         .).
/*------------------------------------------------------------------------*/
Term<out Types type>       (. Types type1; Op op; .)
= Factor<out type>
  { MulOp<out op>
    Factor<out type1>    (. if (type != Types.integer || type1 != Types.integer)
                              SemErr("integer type expected"); .)
	}.
/*------------------------------------------------------------------------
RType<out type> (. int type1 .)                 
= 
  ( "fun" '('  ')' RType<out type1>   (. type = type1; .)
  | "int"                            (. type = Types.integer; .)
  | "bool"                           (. type = Types.boolean; .)
   ).*/
/*------------------------------------------------------------------------*/ 
Type<out Types type>
= 						  (. type = Types.undef; .)
  ( "fun"                 (. type = Types.fun; .)
  | "int"                 (. type = Types.integer; .)
  | "bool"                (. type = Types.boolean; .)
   ).
/*------------------------------------------------------------------------*/
VarDecl                  (. string name; ArrayList names = new ArrayList(); Types type; Types type1; Obj obj; .)
= "var"
   Ident<out name>              (. names.Add(name); .)
	( 
		',' Ident<out name>  	    (. names.Add(name); .)
			{ ',' Ident<out name>  (. names.Add(name); .)
		} Type<out type> ';'          (. foreach(string n in names)
						    			{ tab.NewObj(n, Kinds.var, type); }.)

		| Type<out type>            
				( ';'									(. tab.NewObj((string)names[0], Kinds.var, type); .)
	
	  			   |'=' Expr<out type1>  ';'			(. if (type != type1) SemErr("incompatible types");
					 									   tab.NewObj((string)names[0], Kinds.var, type);
															obj = tab.Find(name);.)	
				)
	).

END Fun.
