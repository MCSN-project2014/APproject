using System.Collections;
using System.Collections.Generic;

COMPILER Fun

	/*const int // types
	  undef = 0, integer = 1, boolean = 2, fun = 3;

	const int // object kinds
	  var = 0, proc = 1, func = 2, form = 3, act=4;
	*/
	
	public SymbolTable   tab;
	public ASTGenerator  gen;

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.
  print  = '"'{letter | digit }'"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
							 
Fun =																			(. Node node; .)
																				(. tab.OpenScope();  
																					node = new Node(Labels.Program); 
																					gen.initAST(node); .)

		{ ProcDecl }
																				(. tab.CloseScope(); .).
   
                                                    
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
ProcDecl =																		(. Types type; string name; Obj proc; Obj formal; Obj obj; 
																				   RType rtype; Node fundecl,block,node1; Term parameter;     .)
			"fun"																	
			(
			    Ident<out name>													(. proc = tab.NewObj(name, Kinds.proc, Types.undef);
																				   fundecl = new Node(Labels.FunDecl, proc);
																				   
																				   tab.OpenScope(proc);                             .)
				'(' 
					{ Ident<out name> Type<out type>							(. formal = tab.NewObj(name, Kinds.var, type); 
																				   tab.addFormal(proc,formal);
																				   parameter = new Term(formal);
																				   fundecl.addChildren(parameter);           .)
				    {',' Ident<out name> Type<out type>							(. formal = tab.NewObj(name, Kinds.var, type); 
																				   tab.addFormal(proc,formal); 
																				   parameter = new Term(formal);
																				   fundecl.addChildren(parameter);               .)
					}
					}
				 ')' 
				  RType<out rtype>												 (. block = new Node(Labels.Block);  
																				    tab.setRType(proc,rtype);
																					.)
		        '{' {VarDecl<out node1>											 (. block.addChildren(node1); .)	 
					| Stat} '}'
																				 (. fundecl.addChildren(0,block);
																					gen.addChildren(fundecl);
																				    tab.CloseScope(); .)
			  | "main"															 (. obj = tab.NewObj("Main", Kinds.proc, Types.undef);
																				    	
																				    
																				    tab.OpenScope();	.)	
				'(' ')' '{'  { VarDecl<out node1> | Stat } '}'								
																				(.  tab.CloseScope(); .)
			).   
			
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
                                                                
AProcDecl<out Obj robj> 														(. string name; Types type; RType rtype; Obj formal;
																					Node node;.)
 =																				(. robj = tab.NewObj(null, Kinds.proc, Types.undef);		    
																				   tab.OpenScope(robj); .)	
			"fun"'(' {Ident<out name> Type<out type>							(. formal = tab.NewObj(name, Kinds.var, type); 
																				   tab.addFormal(robj,formal); .)
				      {',' Ident<out name> Type<out type>						(. formal = tab.NewObj(name, Kinds.var, type);
																				   tab.addFormal(robj,formal); .)
					  }} ')' RType<out rtype>									(. tab.setRType(robj,rtype); .)            
		    '{' {VarDecl<out node> | Stat} '}'                       			        
																				(. tab.CloseScope(); .).
                                                              
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
                                                                             
Stat             																(. Types type; string name; string name1; Obj obj, obj1, robj;
																				   Queue<Types> actualTypes = new Queue<Types>();
																				   Node node; ASTNode exprnode; .) 

= 
	Ident<out name>																(. obj = tab.Find(name); .)                                                               
		(                                                                    
			'='																	(. if ( obj.kind != Kinds.var )
																					   SemErr("cannot assign to procedure"); .)
				(                                                            
				                                                               
				      "async" '{' "return" Ident<out name1>						(. obj1 = tab.Find(name1); .)
								 '(' { CompleteExpr<out type, out exprnode>		(. actualTypes.Enqueue(type); .) 
									 {',' CompleteExpr<out type, out exprnode>	(. actualTypes.Enqueue(type); .) 
									 } } ')' '}'';'								(. if (obj1.kind != Kinds.proc) 
																				       SemErr("object is not a procedure");
																				   if (obj1.type == Types.fun)
																					   SemErr("wrong return type");
																				   tab.checkActualFormalTypes(obj1,actualTypes); 
																				   if(obj.type != obj1.type) 
																					   SemErr("incompatible types"); .)
					| CompleteExpr<out type, out exprnode>';'									(. if (type != obj.type)
																					    SemErr("incompatible types"); .)
					| AProcDecl<out robj>
					| "readln" '{''}' ';'									    (. if(obj.type != Types.integer) 
																						SemErr("incompatible types"); .) 
				                                                              
				)                                                            
			                                                                 
			| '(' { CompleteExpr<out type, out exprnode>										(. actualTypes.Enqueue(type); .) 
				  { ',' CompleteExpr<out type, out exprnode>									(. actualTypes.Enqueue(type); .) 
				  } } ')' ';'													(. if (obj.kind != Kinds.proc || obj.rtype == null) 
																						SemErr("object is not a procedure");
																				   else
																						tab.checkActualFormalTypes(obj,actualTypes); .)
                                                                                
			                                                                  
		)                                                       
		                                                                     
	| "if" CompleteExpr<out type, out exprnode>												(. if (type != Types.boolean) 
																					  SemErr("boolean type expected"); .)
	   Stat [ "else"	Stat ] 
	                                 
	| "While" CompleteExpr<out type, out exprnode>											(. if (type != Types.boolean) 
																					  SemErr("boolean type expected"); .) 
	   Stat                                   
	| "for" Ident<out name> '=' CompleteExpr<out type, out exprnode>';'						(. obj=tab.Find(name);
																				   if (type != obj.type)
																					  SemErr("incompatible types"); .)
		    CompleteExpr<out type, out exprnode>';'											(. if (type != Types.boolean) 
																					  SemErr("boolean type expected"); .)
		    Ident<out name1> '=' CompleteExpr<out type, out exprnode>							(. obj=tab.Find(name1); 
																				   if (type != obj.type)
																					  SemErr("incompatible types");.)				
			Stat
																				
    | "println" '{'{ print } '}' ';'
	| "return" 
			(  
    			                                                               
   				CompleteExpr<out type, out exprnode> ';'										(. obj = tab.getOwner();
																				   obj.returnIsSet=true;
																				   if( obj.type != type )
																					   SemErr("incompatible return type"); .)                                                 
			   | AProcDecl<out robj>                                             (.  obj = tab.getOwner(); 
																					obj.returnIsSet=true;
																					tab.complexReturnTypeControl(obj,robj); .) 
			                                                                  
			)                                                                    
	|																			(. tab.OpenScope(); .) 
	'{' { Stat | VarDecl<out node> } '}'
																				(. tab.CloseScope(); .).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

VarDecl<out Node node>															(. string name; ArrayList names = new ArrayList(); 
																					Types type; Types type1; 
																					Term term; Obj obj; ASTNode exprnode;.)

=		  "var" Ident<out name>													(. node =  new Node (Labels.AssigDecl);
																				   names.Add(name); .)	
		  (
			',' Ident<out name>													(. names.Add(name); .) 
			{',' Ident<out name>												(. names.Add(name); .)
			} Type<out type> ';'												(. foreach(string n in names)
																				   {
						    															obj = tab.NewObj(n, Kinds.var, type);
																					} 
																				.)
			
			| Type<out type>
			  
			  (
				';'																(. obj = tab.NewObj((string)names[0], Kinds.var, type);
																				   node =  new Node (Labels.Decl);
																				   term =  new Term (obj);
																				   node.addChildren(term);                             .)
				| '=' 
					(	"readln" '{''}'';'										(. if(type != Types.integer)
																					  SemErr("incompatible types"); 
																				   obj = tab.NewObj((string)names[0], Kinds.var, type);
																				   node =  new Node (Labels.AssigDecl);
																				   term =  new Term (obj);
																				   Node readln = new Node(Labels.Read);
																				   node.addChildren(term);
																				   node.addChildren(readln); .)	

					    |CompleteExpr<out type1, out exprnode>';'				(. if (type != type1) 
																					   SemErr("incompatible types");
					 															   obj = tab.NewObj((string)names[0], Kinds.var, type); 
																				   node =  new Node (Labels.Decl);
																				   term =  new Term (obj);
																				   node.addChildren(term);
																				   node.addChildren(exprnode); .)		 
						| AProcDecl<out obj>
					)
			  )
		  
		  ).
		  
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

CompleteExpr<out Types type, out ASTNode node>									 (. Types type1; .)
= Expr<out type,out node>											
  [ BoolOp							
	Expr<out type1,out node>													 (. if (type != type1)
																						SemErr("incompatible types");
																					type = Types.boolean; .)
  ].

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Expr<out Types type,out ASTNode node>											 (. Types type1; .)
= SimpExpr<out type, out node> 
  [ RelOp
	SimpExpr<out type1, out node>												 (. if (type != type1)
																	         		    SemErr("incompatible types");
																					type = Types.boolean; .) 
  ].

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

SimpExpr<out Types type, out ASTNode node>											 (. Types type1; ASTNode op, firstTerm, secondTerm; .)
= Term<out type, out firstTerm>														 (. node = firstTerm; .)	 
  { AddOp<out op>																	 (. node = op; .)
    Term<out type1,out secondTerm>													 (. if (type != Types.integer || type1 != Types.integer)
																						  SemErr("integer type expected"); 
																						((Node)op).addChildren(firstTerm);
																						((Node)op).addChildren(secondTerm); .)
  }. 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Term<out Types type, out ASTNode node>  										(. Types type1; ASTNode op, firstTerm, secondTerm; .)
= Factor<out type, out firstTerm>												(. node = firstTerm; .)
  { MulOp<out op>																(. node = op; .)
    Factor<out type1,out secondTerm>											(. if (type != Types.integer || type1 != Types.integer)
																					   SemErr("integer type expected");
																					   ((Node)op).addChildren(firstTerm);
																					   ((Node)op).addChildren(secondTerm); .)
  }.

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Factor<out Types type, out ASTNode node>										(. int n; Obj obj; string name; Types type1; bool control = false;
																				   Queue<Types> actualTypes = new Queue<Types>(); ASTNode exprnode; .) 

=																				(. type = Types.undef;
																				   node = new Node(Labels.Block);.)
	(																		    
		Ident<out name>															(. obj = tab.Find(name); 
																				   type = obj.type; .) 
		[																		(. control = true; .)
		'(' { CompleteExpr<out type1, out exprnode>											(. actualTypes.Enqueue(type1); .) 
			 { ',' CompleteExpr<out type1, out exprnode>										(. actualTypes.Enqueue(type1); .) 
			 } } ')'															(. if (obj.kind != Kinds.proc || obj.rtype == null) 
																						SemErr("object is not a procedure");
																				   else
																						tab.checkActualFormalTypes(obj,actualTypes); .)
		]																		
																				(. if (!control && obj.kind != Kinds.var)
																				      SemErr("variable expected"); .)
		| number																(. n = Convert.ToInt32(t.val);
																				   node =  new Term(n);
																				   type = Types.integer; .)
		| '-'Factor<out type,out node>											(. if (type != Types.integer) 
																					   SemErr("integer type expected");
																				   type = Types.integer; .)
		| "true"																(. type = Types.boolean; .)
		| "false"																(. type = Types.boolean; .)
	).	 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

RType<out RType rtype>																			(. Queue<Types> formals; Types type; 
																								   RType rtype1;	.)
=																								(. rtype = new RType(); .) 																						
		(
		  "fun"																					(. rtype.type = Types.fun;
																								   formals = new Queue<Types>(); .)

		      '(' { Type<out type>																(. formals.Enqueue(type); .)
			      {',' Type<out type>															(. formals.Enqueue(type); .)
				  }} ')'																		
				  RType<out rtype1>																(. rtype1.formals = formals;
																								   rtype.next = rtype1;.)	 
						
		| "int"																					(.  rtype.type = Types.integer; .) 
		| "bool"																				(.  rtype.type = Types.boolean; .)
		).
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

Type<out Types type> 
=																				(. type = Types.undef; .)
 (																				
	  "fun"																		(. type = Types.fun; .) 
	| "int"																		(. type = Types.integer; .)
	| "bool"																	(. type = Types.boolean; .)
  ).		
		
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

AddOp<out ASTNode op>
=															(. op = new Node(Labels.Plus); .)					
  (																				
	  '+' 
	| '-'													(. op = new Node(Labels.Minus); .)												
   ).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

RelOp
 =																				
	(																			
	   '<'																			
	 | '>' 
	 | "==" 
	 | "!=" 
	 | "<=" 
	 | ">="
   ). 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

BoolOp
 =																				
	(																			
	    "&&" 
	  | "||"
	).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

MulOp<out ASTNode op>
 =														(. op = new Node(Labels.Mul); .)					
	(																			
	    '*' 
	  | '/'												(. op = new Node(Labels.Div); .)									
	).               

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

Ident<out string name>
 = ident																		(. name = t.val; .).

	  
END Fun.