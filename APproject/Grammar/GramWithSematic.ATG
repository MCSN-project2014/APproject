using System.Collections;
using System.Collections.Generic;

COMPILER Fun

	/*const int // types
	  undef = 0, integer = 1, boolean = 2, fun = 3;

	const int // object kinds
	  var = 0, proc = 1, func = 2, form = 3, act=4;
	*/
	
	public SymbolTable   tab;
	public ASTGenerator  gen;

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.
  print  = '"'{letter | digit }'"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
							 
Fun =																			(. ASTNode node; .)
																				(. tab.OpenScope();  
																					node = new Node(Labels.Program); 
																					gen.initAST((Node) node); .)

		{ ProcDecl }
																				(. tab.CloseScope(); .).
   
                                                    
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
ProcDecl =																		 (. Types type; string name; Obj proc; Obj formal;
																				    RType rtype; ASTNode fundecl, node1; Term parameter;     .)
			"fun"																	
			(
			    Ident<out name>													 (. proc = tab.NewObj(name, Kinds.proc, Types.undef);
																				    fundecl = new Node(Labels.FunDecl, proc);
																				   
																				    tab.OpenScope(proc);                             .)
				'(' 
					{ Ident<out name> Type<out type>							 (. formal = tab.NewObj(name, Kinds.var, type); 
																				    tab.addFormal(proc,formal);
																				    parameter = new Term(formal);
																				    ((Node)fundecl).addChildren(parameter);           .)
				    {',' Ident<out name> Type<out type>							 (. formal = tab.NewObj(name, Kinds.var, type); 
																				    tab.addFormal(proc,formal); 
																				    parameter = new Term(formal);
																				    ((Node)fundecl).addChildren(parameter);               .)
					}
					}
				 ')'															 (. Node block = new Node(Labels.Block);  .)
				  RType<out rtype>												 (. tab.setRType(proc,rtype);        .)
		        '{' {   VarDecl<out node1>	         							 (. ((Node)block).addChildren(node1); .)	 
					  | Stat<out node1> 										 (. ((Node)block).addChildren(node1);    .) 
				 } '}'																
																			     (. ((Node)fundecl).addChildren(0,block);
																				    gen.addChildren((Node)fundecl);
																				    tab.CloseScope(); .)

			  | "main"															 (. tab.NewObj("Main", Kinds.proc, Types.undef);
																				    fundecl = new Node(Labels.Main);
																				    tab.OpenScope();	.)
																				 (. Node block = new Node(Labels.Block);  .) 	
				'(' ')' '{'  { VarDecl<out node1>								 (.	((Node)block).addChildren(node1);    .)
							  | Stat<out node1>      							 (. ((Node)block).addChildren(node1);    .) 		
						 }  '}'	
						    													 (. ((Node)fundecl).addChildren(0,block);
																					gen.addChildren((Node)fundecl);
																				    tab.CloseScope(); .)
			).   
			
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
                                                                
AProcDecl<out Obj robj, out ASTNode node> 									    (. string name; Types type; RType rtype; Obj formal;
																					ASTNode block, vardeclnode, statnode; Term parameter;.)
 =																				(. node = new Node(Labels.Afun);
																				   robj = tab.NewObj(null, Kinds.proc, Types.undef);		    
																				   tab.OpenScope(robj); .)	
			"fun"'(' {Ident<out name> Type<out type>							(. formal = tab.NewObj(name, Kinds.var, type); 
																				   tab.addFormal(robj,formal); 
																				   parameter = new Term(formal);
																				   ((Node)node).addChildren(parameter);.)
				      {',' Ident<out name> Type<out type>						(. formal = tab.NewObj(name, Kinds.var, type);
																				   tab.addFormal(robj,formal); 
																				   parameter = new Term(formal);
																				   ((Node)node).addChildren(parameter); .)
					  }} ')' RType<out rtype>									(. block = new Node(Labels.Block);
																				   tab.setRType(robj,rtype); .) 
																				              
		    '{' {	VarDecl<out vardeclnode>									(. ((Node)block).addChildren(vardeclnode); .)	
					| Stat<out statnode>                         			    (. ((Node)block).addChildren(statnode);    .)  
			 } '}'	  
																				(. ((Node)node).addChildren(0,block);
																				   tab.CloseScope(); .).
                                                              
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
                                                                             
Stat<out ASTNode node>															(. Types type,type1; string name; string name1; Obj obj, obj1, robj;
																				   Queue<Types> actualTypes = new Queue<Types>();
																			       ASTNode node1;  
																			       node = new Node(Labels.Assig); .) 
=																				
	Ident<out name>																(. obj = tab.Find(name); 
																					.)                                                               
		(                                                                    
			'='																	(. if ( obj.kind != Kinds.var )
																					   SemErr("cannot assign to procedure"); .)
				(                                                            
				                                                               
				      "async" '{' "return" Ident<out name1>						(. Node async =  new Node(Labels.Async);
																				   obj1 = tab.Find(name1);	
																				   Node call = new Node(Labels.FunCall, obj1); .)
								 '(' { (
									 	  CompleteExpr<out type, out node1>		(. actualTypes.Enqueue(type); 
																				   ((Node)call).addChildren(node1);	.) 
										  | AProcDecl<out robj, out node1>		(. actualTypes.Enqueue(Types.fun);
																				   ((Node)call).addChildren(node1); .)
										)

									 {','(
										   CompleteExpr<out type, out node1>	(. actualTypes.Enqueue(type);
																				   ((Node)call).addChildren(node1); .) 
										   | AProcDecl<out robj, out node1>	    (. actualTypes.Enqueue(Types.fun);
																				   ((Node)call).addChildren(node1); .)
										  )
									 } } ')'									
											 '}'';'								(. ((Node)async).addChildren(call);
																				   ((Node)node).addChildren(new Term(obj));
																				   ((Node)node).addChildren(async); .)
																				(. if (obj1.kind != Kinds.proc) 
																				       SemErr("object is not a procedure");
																				   if (obj1.type == Types.fun)
																					   SemErr("wrong return type");
																				   tab.checkActualFormalTypes(obj1, actualTypes); 
																				   if(obj.type != obj1.type) 
																					   SemErr("incompatible types"); .)

					| CompleteExpr<out type, out node1>';'					    (. if (type != obj.type)
																					    SemErr("incompatible types");
																				   ((Node)node).addChildren(new Term(obj));
																				   ((Node)node).addChildren(node1); .)

					| AProcDecl<out robj, out node1>';'							(. ((Node)node).addChildren(new Term(obj));
																				   ((Node)node).addChildren(node1); .)

					| "readln" '{''}' ';'									    (. if(obj.type != Types.integer) 
																						SemErr("incompatible types");
																				   ((Node)node).addChildren(new Term(obj)); 
																				   ((Node)node).addChildren(new Node(Labels.Read));
																				 .) 
				                                                              
				)                                                            
			                                                                 
			| '('																(. node = new Node(Labels.FunCall, obj); .)
																				   
				  { ( 
					    CompleteExpr<out type, out node1>						(. actualTypes.Enqueue(type);
																				   ((Node)node).addChildren(node1); .)
					   | AProcDecl<out robj, out node1>							(. actualTypes.Enqueue(Types.fun);
																				   ((Node)node).addChildren(node1); .)
					 
					 )											 
				  { ','
				      ( 
						CompleteExpr<out type, out node1>						(. actualTypes.Enqueue(type); 
																				   ((Node)node).addChildren(node1); .)
						| AProcDecl<out robj, out node1>						(. actualTypes.Enqueue(Types.fun);
																				   ((Node)node).addChildren(node1); .)
					  ) 
				  } } ')' ';'													(. if (obj.kind != Kinds.proc || obj.rtype == null) 
																						SemErr("object is not a procedure");
																				   else
																						tab.checkActualFormalTypes(obj,actualTypes); .)
                                                                                
			                                                                  
		)                                                       
		                                                                     
	| "if" CompleteExpr<out type, out node1>									   (.  node = new Node(Labels.If);
																				       ((Node)node).addChildren(node1);
																					   Node thenBlock = new Node(Labels.Block);
																					   if (type != Types.boolean) 
																						  SemErr("boolean type expected"); .)
																					(. tab.OpenScope(); .) 
	 '{' { Stat<out node1>															(. ((Node)thenBlock).addChildren(node1);.) 
		   | VarDecl<out node1>														(. ((Node)thenBlock).addChildren(node1); .)	 
	  } '}'																			(. ((Node)node).addChildren(thenBlock);
																						tab.CloseScope(); .)

	  [																				(. tab.OpenScope(); .)
	   "else"																		(. Node elseBlock = new Node(Labels.Block); .)
	  '{' {    Stat<out node1>														(. ((Node)elseBlock).addChildren(node1);.) 
			| VarDecl<out node1>													(. ((Node)elseBlock).addChildren(node1); .)	 	
	   } '}'																		(. ((Node)node).addChildren(elseBlock);
																					   tab.CloseScope(); .)
	  ] 
	                                 
	| "while" CompleteExpr<out type, out node1>									    (. node = new Node(Labels.While);
																					   ((Node)node).addChildren(node1);
																					   Node whileBlock =new Node(Labels.Block);
																					   if (type != Types.boolean) 
																					       SemErr("boolean type expected"); .) 
	   																				(. tab.OpenScope(); .) 
	 '{' { Stat<out node1>															(. ((Node)whileBlock).addChildren(node1);.) 
		   | VarDecl<out node1>														(. ((Node)whileBlock).addChildren(node1); .)	 
	  } '}'																			(.  ((Node)node).addChildren(whileBlock);
																						tab.CloseScope(); .)
	                                
	| "for"																				    (. tab.OpenScope(); 
																							   node = new Node(Labels.For); .) 
	   "var" Ident<out name> Type<out type> '=' CompleteExpr<out type1, out node1>';'	    (. if (type != type1)
																								   SemErr("incompatible types");
																							   obj = tab.NewObj(name, Kinds.var, type);
																							   Node declAssig = new Node (Labels.AssigDecl);
																							   ((Node)declAssig).addChildren(new Term(obj));
																							   ((Node)declAssig).addChildren(node1);
																							   ((Node)node).addChildren(declAssig); .)
		    CompleteExpr<out type, out node1>';'											(. ((Node)node).addChildren(node1);
																							   if (type != Types.boolean) 
																								   SemErr("boolean type expected"); .)
		    Ident<out name1> '=' CompleteExpr<out type, out node1>						    (. obj = tab.Find(name1); 
																							   Node assig = new Node(Labels.Assig);
																							   ((Node)assig).addChildren(new Term(obj));
																							   ((Node)assig).addChildren(node1);
																							   ((Node)node).addChildren(assig);
																							   Node forBlock =new Node(Labels.Block);
																							   if (type != obj.type)
					    																		   SemErr("incompatible types"); .)				
			  																		
	 '{' { Stat<out node1>																	(. ((Node)forBlock).addChildren(node1);.) 
		   | VarDecl<out node1>																(. ((Node)forBlock).addChildren(node1); .)	 
	  } '}'																					(. ((Node)node).addChildren(forBlock);
																								tab.CloseScope(); .)
																				
    | "println"'{'																(.  node = new Node(Labels.Print); .)
				  {CompleteExpr<out type, out node1>							(.  ((Node)node).addChildren(node1); .)
				  }'}'';'						
																				  
		
	| "return"																	(. node = new Node(Labels.Return);
																				   bool controlofblock; .)
			(  
    			                                                               
   				CompleteExpr<out type, out node1> ';'						    (. ((Node)node).addChildren(node1);
																				   
																				   tab.getOwner(out obj,out controlofblock);
																				   if(obj != null){
																						if(controlofblock)
																							obj.returnIsSet=true;
																						if( obj.type != type )
																							SemErr("incompatible return type");
																					} .)                                                 
			   | AProcDecl<out robj,out node1> ';'                                  (. ((Node)node).addChildren(node1);
																					tab.getOwner(out obj,out controlofblock);
																					if(obj != null){ 
																						if(controlofblock)
																							obj.returnIsSet=true;
																						tab.complexReturnTypeControl(obj,robj);
																					} .) 
			).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

VarDecl<out ASTNode node>														(. string name; ArrayList names = new ArrayList(); 
																					Types type; Types type1; Obj obj, afobj; ASTNode node1;.)

=		  "var" Ident<out name>													(. node =  new Node (Labels.AssigDecl);
																				   names.Add(name); .)	
		  (
			',' Ident<out name>													(. names.Add(name); .) 
			{',' Ident<out name>												(. names.Add(name); .)
			} Type<out type> ';'												(. node =  new Node (Labels.Decl);
																				   foreach(string n in names)
																				   {
						    															obj = tab.NewObj(n, Kinds.var, type);
																						((Node)node).addChildren(new Term (obj)); 

																					} 
																				.)
			
			| Type<out type>
			  
			  (
				';'																(. obj  =  tab.NewObj((string)names[0], Kinds.var, type);
																				   node =  new Node (Labels.Decl);
																				   ((Node)node).addChildren(new Term (obj));                             .)
				| '=' 
					(	"readln" '{''}'';'										(. if(type != Types.integer)
																					  SemErr("incompatible types"); 
																				   obj = tab.NewObj((string)names[0], Kinds.var, type);
																				   node =  new Node (Labels.AssigDecl);
																				   ((Node)node).addChildren(new Term (obj));
																				   ((Node)node).addChildren(new Node(Labels.Read)); .)	

					    | CompleteExpr<out type1, out node1>';'				    (. if (type != type1) 
																					   SemErr("incompatible types");
					 															   obj = tab.NewObj((string)names[0], Kinds.var, type); 
																				   node =  new Node (Labels.AssigDecl);
																				   ((Node)node).addChildren(new Term (obj));
																				   ((Node)node).addChildren(node1); .)	
																				   	 
						| AProcDecl<out afobj,out node1> ';'					(. if (type != Types.fun) 
																					   SemErr("incompatible types");
					 															   obj = tab.NewObj((string)names[0], Kinds.var, type); 
																				   node =  new Node (Labels.AssigDecl);
																				   ((Node)node).addChildren(new Term (obj));
																				   ((Node)node).addChildren(node1);   .)
					)
			  )
		  
		  ).
		  
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

CompleteExpr<out Types type, out ASTNode node>									 (. Types type1; ASTNode op, firstExpr, secondExpr; .)
= Expr<out type,out firstExpr>													 (. node = firstExpr; .)
  { BoolOp<out op>																 (. node = op; .)
	Expr<out type1,out secondExpr>												 (. if (type != type1)
																						SemErr("incompatible types");
																					type = Types.boolean; 
																					((Node)op).addChildren(firstExpr);
																					((Node)op).addChildren(secondExpr); .)
  }.

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Expr<out Types type,out ASTNode node>											 (. Types type1; ASTNode op, firstSimpExpr, secondSimpExpr; .)
= SimpExpr<out type, out firstSimpExpr>											 (. node = firstSimpExpr; .)
  [ RelOp<out op>																 (. node = op; .)
	SimpExpr<out type1, out secondSimpExpr>										 (. if (type != type1)
																	         		    SemErr("incompatible types");
																					type = Types.boolean;
																					((Node)op).addChildren(firstSimpExpr);
																					((Node)op).addChildren(secondSimpExpr); .) 
  ].

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

SimpExpr<out Types type, out ASTNode node>										 (. Types type1; ASTNode op, firstTerm, secondTerm; .)
= Term<out type, out firstTerm>													 (. node = firstTerm; .)	 
  { AddOp<out op>																 (. node = op; .)
    Term<out type1,out secondTerm>												 (. if (type != Types.integer || type1 != Types.integer)
																					   SemErr("integer type expected"); 
																					((Node)op).addChildren(firstTerm);
																					((Node)op).addChildren(secondTerm); .)
  }. 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Term<out Types type, out ASTNode node>  										(. Types type1; ASTNode op, firstfactor, secondfactor; .)
= Factor<out type, out firstfactor>												(. node = firstfactor; .)
  { MulOp<out op>																(. node = op; .)
    Factor<out type1,out secondfactor>											(. if (type != Types.integer || type1 != Types.integer)
																					   SemErr("integer type expected");
																					   ((Node)op).addChildren(firstfactor);
																					   ((Node)op).addChildren(secondfactor); .)
  }.

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Factor<out Types type, out ASTNode node>									(. int n; Obj obj,robj; string name; Types type1; bool control = false;
																			   Queue<Types> actualTypes = new Queue<Types>(); ASTNode node1; .) 

=																				(. type = Types.undef;
																				   node = null;.)
	(																		    
		Ident<out name>															(. obj = tab.Find(name);
																				   node = new Term(obj); 
																				   type = obj.type; .) 
		[																		(. control = true; 
																				   node = new Node(Labels.FunCall, obj); .)
		'(' { (
				 CompleteExpr<out type1, out node1>								(. actualTypes.Enqueue(type1);
																				   ((Node)node).addChildren(node1); .) 
				| AProcDecl<out robj, out node1>								(. actualTypes.Enqueue(Types.fun);
																				   ((Node)node).addChildren(node1); .)
			  
			  )

			 { ','
				(
				  CompleteExpr<out type1, out node1>							(. actualTypes.Enqueue(type1); 
																				   ((Node)node).addChildren(node1); .)
				  | AProcDecl<out robj, out node1>								(. actualTypes.Enqueue(Types.fun);
																				   ((Node)node).addChildren(node1); .)
			  
			   ) 
			 } } ')'															(. if (obj.kind != Kinds.proc || obj.rtype == null) 
																						SemErr("object is not a procedure");
																				   else
																						tab.checkActualFormalTypes(obj, actualTypes); .)
		]																		
																				(. if (!control && obj.kind != Kinds.var)
																				      SemErr("variable expected"); .)

		| number																(. n = Convert.ToInt32(t.val);
																				   node =  new Term(n);
																				   type = Types.integer; .)
		| '-'Factor<out type,out node1>											(. node = new Node(Labels.Negativ);
																				   ((Node)node).addChildren(node1);	
																				   if (type != Types.integer) 
																					   SemErr("integer type expected");
																				   type = Types.integer; .)
		| "true"																(. node = new Term(true);
																				   type = Types.boolean; .)
		| "false"																(. node = new Term(false);
																				   type = Types.boolean; .)
	).	 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

RType<out RType rtype>																			(. Queue<Types> formals; Types type; 
																								   RType rtype1;	.)
=																								(. rtype = new RType(); .) 																						
		(
		  "fun"																					(. rtype.type = Types.fun;
																								   formals = new Queue<Types>(); .)

		      '(' { Type<out type>																(. formals.Enqueue(type); .)
			      {',' Type<out type>															(. formals.Enqueue(type); .)
				  }} ')'																		
				  RType<out rtype1>																(. rtype1.formals = formals;
																								   rtype.next = rtype1;.)	 
						
		| "int"																					(.  rtype.type = Types.integer; .) 
		| "bool"																				(.  rtype.type = Types.boolean; .)
		).
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

Type<out Types type> 
=																				(. type = Types.undef; .)
 (																				
	  "fun"																		(. type = Types.fun; .) 
	| "int"																		(. type = Types.integer; .)
	| "bool"																	(. type = Types.boolean; .)
  ).		
		
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

AddOp<out ASTNode op>
=															(. op = new Node(Labels.Plus); .)					
  (																				
	  '+' 
	| '-'													(. op = new Node(Labels.Minus); .)												
   ).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

RelOp<out ASTNode op>
 =																(. op = new Node(Labels.Lt); .)				
	(																			
	   '<'																		
	 | '>'														(. op = new Node(Labels.Gt); .)
	 | "=="														(. op = new Node(Labels.Eq); .)
	 | "!="														(. op = new Node(Labels.NotEq); .)
	 | "<="														(. op = new Node(Labels.Lte); .)	
	 | ">="														(. op = new Node(Labels.Gte); .)
   ). 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

BoolOp<out ASTNode op>
 =																(. op = new Node(Labels.And); .)														
	(																			
	    "&&" 
	  | "||"													(. op = new Node(Labels.Or);  .)
	).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

MulOp<out ASTNode op>
 =														(. op = new Node(Labels.Mul); .)					
	(																			
	    '*' 
	  | '/'												(. op = new Node(Labels.Div); .)									
	).               

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

Ident<out string name>
 = ident												(. name = t.val; .).

	  
END Fun.