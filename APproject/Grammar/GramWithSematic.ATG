using System.Collections;
using System.Collections.Generic;

COMPILER Fun

	/*const int // types
	  undef = 0, integer = 1, boolean = 2, fun = 3;

	const int // object kinds
	  var = 0, proc = 1, func = 2, form = 3, act=4;
	*/
	
	public SymbolTable   tab;
	public ASTGenerator  gen;

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

CHARACTERS
  letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".
  digit = "0123456789".
  cr  = '\r'.
  lf  = '\n'.
  tab = '\t'.

TOKENS
  ident  = letter {letter | digit}.
  number = digit {digit}.
  print  = '"'{letter | digit }'"'.

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

PRODUCTIONS

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
							 
Fun =																			(. tab.OpenScope();  .)
		{ ProcDecl }
																				(. tab.CloseScope(); .).
   
                                                    
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
ProcDecl =																		(. Types type; string name; Obj proc; Obj formal; Obj obj; 
																				   RType rtype; Node node;     .)
			"fun"
			(
			    Ident<out name>													(. proc = tab.NewObj(name, Kinds.proc, Types.undef);
																				   tab.OpenScope(proc);                             .)
				'(' 
					{ Ident<out name> Type<out type>							(. formal = tab.NewObj(name, Kinds.var, type); 
																				   tab.addFormal(proc,formal);             .)
				    {',' Ident<out name> Type<out type>							(. formal = tab.NewObj(name, Kinds.var, type); 
																				   tab.addFormal(proc,formal);             .)
					}
					}
				 ')' 
				  RType<out rtype>												 (. tab.setRType(proc,rtype); .)
		        '{' {VarDecl | Stat} '}'
																				 (. tab.CloseScope(); .)
			  | "main"															 (. obj = tab.NewObj("Main", Kinds.proc, Types.undef);
																				    node = new Node(Labels.Main); 	
																				    //gen.initAST(node);
																				    tab.OpenScope();	.)	
				'(' ')' '{'  { VarDecl | Stat } '}'								
																				 (.  tab.CloseScope(); .)
			).   
			
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
                                                                
AProcDecl<out Obj robj> 														(. string name; Types type; RType rtype; Obj formal;.)
 =																				(. robj = tab.NewObj(null, Kinds.proc, Types.undef);		    
																				   tab.OpenScope(); .)	
			"fun"'(' {Ident<out name> Type<out type>							(. formal = tab.NewObj(name, Kinds.var, type); 
																				   tab.addFormal(robj,formal); .)
				      {',' Ident<out name> Type<out type>						(. formal = tab.NewObj(name, Kinds.var, type);
																				   tab.addFormal(robj,formal); .)
					  }} ')' RType<out rtype>									(. tab.setRType(robj,rtype); .)            
		    '{' {VarDecl | Stat} '}'                       			        
																				(. tab.CloseScope(); .).
                                                              
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/
                                                                             
Stat																			(. Types type; string name; string name1; Obj obj, obj1, robj;
																				   Queue<Types> actualTypes = new Queue<Types>(); .) 

= 
	Ident<out name>																(. obj = tab.Find(name); .)                                                               
		(                                                                    
			'='																	(. if ( obj.kind != Kinds.var )
																					   SemErr("cannot assign to procedure"); .)
				(                                                            
				                                                               
				      "async" '{' "return" Ident<out name1>						(. obj1 = tab.Find(name1); .)
								 '(' { CompleteExpr<out type>					(. actualTypes.Enqueue(type); .) 
									 {',' CompleteExpr<out type>				(. actualTypes.Enqueue(type); .) 
									 } } ')' '}'';'								(. if (obj1.kind != Kinds.proc) 
																				       SemErr("object is not a procedure");
																				   tab.checkActualFormalTypes(obj1,actualTypes); 
																				   if(obj.type != obj1.type) 
																					   SemErr("incompatible types"); .)
					| CompleteExpr<out type>';'									(. if (type != obj.type)
																					    SemErr("incompatible types"); .)
					| AProcDecl<out robj>
					| "readln" '{''}' ';'									    (. if(obj.type != Types.integer) 
																						SemErr("incompatible types"); .) 
				                                                              
				)                                                            
			                                                                 
			| '(' { CompleteExpr<out type>										(. actualTypes.Enqueue(type); .) 
				  { ',' CompleteExpr<out type>									(. actualTypes.Enqueue(type); .) 
				  } } ')' ';'													(. if (obj.kind != Kinds.proc) 
																				       SemErr("object is not a procedure");
																				   tab.checkActualFormalTypes(obj,actualTypes); .)
                                                                                
			                                                                  
		)                                                       
		                                                                     
	| "if" CompleteExpr<out type>												(. if (type != Types.boolean) 
																					  SemErr("boolean type expected"); .)
	   Stat [ "else"	Stat ] 
	                                 
	| "While" CompleteExpr<out type>											(. if (type != Types.boolean) 
																					  SemErr("boolean type expected"); .) 
	   Stat                                   
	| "for" Ident<out name> '=' CompleteExpr<out type>';'						(. obj=tab.Find(name);
																				   if (type != obj.type)
																					  SemErr("incompatible types"); .)
		    CompleteExpr<out type>';'											(. if (type != Types.boolean) 
																					  SemErr("boolean type expected"); .)
		    Ident<out name1> '=' CompleteExpr<out type>							(. obj=tab.Find(name1); 
																				   if (type != obj.type)
																					  SemErr("incompatible types");.)				
			Stat
																				
    | "println" '{'{ print } '}' ';'
	| "return" 
			(  
    			                                                               
   				CompleteExpr<out type> ';'										(. obj = tab.getOwner();
																				   if( obj.type != type )
																					   SemErr("incompatible return type"); .)                                                 
			   | AProcDecl<out robj>                                            (. obj = tab.getOwner();
																				   tab.complexReturnTypeControl(obj,robj); .) 
			                                                                  
			)                                                                    
	|																			(. tab.OpenScope(); .) 
	'{' { Stat | VarDecl } '}'
																				(. tab.CloseScope(); .).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

VarDecl 																		(. string name; ArrayList names = new ArrayList(); 
																					Types type; Types type1; Node node; 
																					Term term; Obj obj;.)

=		  "var" Ident<out name>													(.  node = new Node(Labels.Decl);
																					names.Add(name); .)	
		  (
			',' Ident<out name>													(. names.Add(name); .) 
			{',' Ident<out name>												(. names.Add(name); .)
			} Type<out type> ';'												(. foreach(string n in names)
																				   {
						    															obj = tab.NewObj(n, Kinds.var, type); 
																						//term =  new Term (obj);
																						//node.addChildren(term);
																						//gen.addChildren(node);
																					} 
																				.)
			
			| Type<out type>
			  
			  (
				';'																(. obj = tab.NewObj((string)names[0], Kinds.var, type);
																				   term =  new Term (obj);
																				   //node.addChildren(term);
																				   //gen.addChildren(node); 
																				   .)
				| '=' 
					(	"readln" '{''}' ';'										(. if(type != Types.integer)
																					  SemErr("incompatible types"); 
																				   tab.NewObj((string)names[0], Kinds.var, type); .)	

					    |CompleteExpr<out type1>';'								(. if (type != type1) 
																					   SemErr("incompatible types");
					 															   tab.NewObj((string)names[0], Kinds.var, type); .)		 
						| AProcDecl<out obj>
					)
			  )
		  
		  ).
		  
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

CompleteExpr<out Types type>													 (. Types type1; .)
= Expr<out type> 
  [ BoolOp
	Expr<out type1>																 (. if (type != type1)
																						SemErr("incompatible types");
																					type = Types.boolean; .)
  ].

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Expr<out Types type>															 (. Types type1; .)
= SimpExpr<out type> 
  [ RelOp
	SimpExpr<out type1>															 (. if (type != type1)
																					    SemErr("incompatible types");
																					type = Types.boolean; .) 
  ].

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

SimpExpr<out Types type>														 (. Types type1;.)
= Term<out type> 
  { AddOp
    Term<out type1>																 (. if (type != Types.integer || type1 != Types.integer)
																						  SemErr("integer type expected"); .) 
  }.

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Term<out Types type>															(. Types type1; .)
= Factor<out type> 
  { MulOp
    Factor<out type1>															(. if (type != Types.integer || type1 != Types.integer)
																					   SemErr("integer type expected"); .)
  }.

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

Factor<out Types type>															(. int n; Obj obj; string name; Types type1; bool control = false;
																				   Queue<Types> actualTypes = new Queue<Types>(); .) 

=																				(. type = Types.undef; .)
	(																		    
		Ident<out name>															(. obj = tab.Find(name); 
																				   type = obj.type; .) 
		[																		(. control = true; .)
		'(' { CompleteExpr<out type1>											(. actualTypes.Enqueue(type1); .) 
			 { ',' CompleteExpr<out type1>										(. actualTypes.Enqueue(type1); .) 
			 } } ')'															(. if (obj.kind != Kinds.proc) 
																				       SemErr("object is not a procedure");
																				   tab.checkActualFormalTypes(obj,actualTypes); .)
		]																		
																				(. if (!control && obj.kind != Kinds.var)
																				      SemErr("variable expected"); .)
		| number																(. n = Convert.ToInt32(t.val);
																				   type = Types.integer; .)
		| '-'Factor<out type>													(. if (type != Types.integer) 
																					   SemErr("integer type expected");
																				   type = Types.integer; .)
		| "true"																(. type = Types.boolean; .)
		| "false"																(. type = Types.boolean; .)
	).	 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

RType<out RType rtype>																			(. Queue<Types> formals; Types type; 
																								   RType rtype1;	.)
=																								(. rtype = new RType(); .) 																						
		(
		  "fun"																					(. rtype.type = Types.fun;
																								   formals = new Queue<Types>(); .)

		      '(' { Type<out type>																(. formals.Enqueue(type); .)
			      {',' Type<out type>															(. formals.Enqueue(type); .)
				  }} ')'																		
				  RType<out rtype1>																(. rtype1.formals = formals;
																								   rtype.next = rtype1;.)	 
						
		| "int"																					(.  rtype.type = Types.integer; .) 
		| "bool"																				(.  rtype.type = Types.boolean; .)
		).
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

Type<out Types type> 
=																				(. type = Types.undef; .)
 (																				
	  "fun"																		(. type = Types.fun; .) 
	| "int"																		(. type = Types.integer; .)
	| "bool"																	(. type = Types.boolean; .)
  ).		
		
/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

AddOp
=																				
  (																				
	  '+' 
	| '-'																			
   ).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

RelOp
 =																				
	(																			
	   '<'																			
	 | '>' 
	 | "==" 
	 | "!=" 
	 | "<=" 
	 | ">="
   ). 

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/		  

BoolOp
 =																				
	(																			
	    "&&" 
	  | "||"
	).

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

MulOp
 =																				
	(																			
	    '*' 
	  | '/'																					
	).               

/*-------------------------------------------------------------------------------------------------------------------------------------------------------*/

Ident<out string name>
 = ident																		(. name = t.val; .).

	  
END Fun.